#lang racket

(define (tagged-list? len sym x)
  (and (list? x)
       (= (length x) len)
       (eq? (first x) sym)))

(define x (list 1 2))
(first x)

(define (elem-val x) (cdr x))

;;;  leftist  heaps (after  Okasaki)
;; data  representation

(define leaf 'leaf)

(define (leaf? h)
  (eq? 'leaf h))

(define (hnode? h)
  (and (tagged-list? 5 'hnode h)
       (natural? (caddr h))))

(define (make-hnode  elem  heap-a  heap-b)
  (cond
    [(> (rank heap-a) (rank heap-b)) (list 'hnode elem (inc (rank heap-b)) heap-a heap-b)]
    [else (list 'hnode elem (inc (rank heap-b)) heap-b heap-a)]))

(define (hnode-elem h)
  (second h))

(define (hnode-left h)
  (fourth h))

(define (hnode-right h)
  (fifth h))

(define (hnode-rank h)
  (third h))

(define (hord? p h)
 (or (leaf? h)
     (<= p (elem-priority (hnode-elem h)))))

(define (inc x)
  (+ 1 x))



(define (elem-priority x)
  (car x))

(define (elt p d)
  (cons p d))

(define (elt-prio c)
  (car c))

(define (elt-data c)
  (cdr c))


(define (heap? h)
  (or (leaf? h)
      (and (hnode? h)
           (heap? (hnode-left h))
           (heap? (hnode-right h))
           (<= (rank (hnode-right h))
               (rank (hnode-left h)))
           (= (rank h) (inc (rank (hnode-right h))))
           (hord? (elem-priority (hnode-elem h))
                  (hnode-left h)))))

(define (rank h)
  (if (leaf? h)
      0
      (hnode-rank h)))

;; operations

(define empty-heap  leaf)

(define (heap-empty? h)
  (leaf? h))

(define (heap-merge heap_a heap_b)
  (cond [(leaf? heap_a) heap_b]
        [(leaf? heap_b) heap_a]
        [else
         (let*
               ([min_a (heap-min heap_a)]
                [min_b (heap-min heap_b)])
             (if (<= (car min_a) (car min_b))
                 (let*
                     ((e min_a)
                     (hl (hnode-left heap_a))
                     (hr (hnode-right heap_a))
                     (h heap_b))
                   
                     (make-hnode e (heap-merge hr h) hl))
                 
                 (let*
                     ((e min_b)
                     (hl (hnode-left heap_b))
                     (hr (hnode-right heap_b))
                     (h heap_a))
                   
                     (make-hnode e (heap-merge hr h) hl))))]))
                     
           

(define (heap-insert  elt  heap)
  (heap-merge  heap (make-hnode  elt  leaf  leaf)))

(define (heap-min  heap)
  (hnode-elem  heap))

(define (heap-pop  heap)
  (heap-merge (hnode-left  heap) (hnode-right  heap)))

(define heap empty-heap)

(define (make-elem pri val)
  (cons pri val))

(define e1 (make-elem 0 'first))
(define e2 (make-elem 1 'second))
(define e3 (make-elem 2 'third))
(define e4 (make-elem 3 'fourth))
(define e5 (make-elem 4 'fifth))

heap
(heap-insert e4 (heap-insert e3 (heap-insert e2 (heap-insert e1 heap))))
(heap-insert e5 (heap-insert e4 (heap-insert e3(heap-insert e2 (heap-insert e1 empty-heap)))))
(heap-insert e1 (heap-insert e2 (heap-insert e3(heap-insert e4 (heap-insert e5 empty-heap)))))

(heap? (heap-insert e5 (heap-insert e4 (heap-insert e3(heap-insert e2 (heap-insert e1 empty-heap))))))
(heap? (heap-insert e1 (heap-insert e1 (heap-insert e1(heap-insert e1 (heap-insert e1 empty-heap))))))
(heap? (heap-insert e1 (heap-insert e4 (heap-insert e3(heap-insert e2 (heap-insert e5 empty-heap))))))
(heap? (heap-insert e1 (heap-insert e2 (heap-insert e3(heap-insert e4 (heap-insert e5 empty-heap))))))


(define (sorted? xs)
  (cond [(null? xs)              true]
        [(null? (cdr xs))        true]
        [(<= (car xs) (cadr xs)) (sorted? (cdr xs))]
        [else                    false]))




(define (heapsort lista)
  (define (make-heap lista)
  (if (null? lista)
      empty-heap
      (heap-insert (make-elem (car lista) (car lista)) (make-heap (cdr lista)))))
  (define (heapsort-aux heap)
    (if (leaf? heap)
        null
        (cons (car (heap-min heap)) (heapsort-aux (heap-pop heap)))))
  (let ([heap (make-heap lista)])
    (heapsort-aux heap)))

(define l1 (list 12 15 23 4 6 10 35 28 100 130 500 1000 235 554 75 345 800 222 333 888 444 111 666 777 60))
(define l2  null)
(define l3 (list 1))
(define l4 (list 5 4 3 2 1))
(define l5 (list 1 2 3 4 5))
(define l6 (list 2 2 2 2))
(define l7 (list 3 6 2 76 5 0 3 346 5))
 
(heapsort l1)
(heapsort l2)
(heapsort l3)
(heapsort l4)
(heapsort l5)
(heapsort l6)
(heapsort l7)
(heapsort (list 4 3 2 1 0))