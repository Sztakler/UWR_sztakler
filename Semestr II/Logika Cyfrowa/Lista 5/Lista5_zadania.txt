#Zadanie 1

W zależności od wejścia 's' odpowiednią ilość razy dodajemy do siebie liczbę 'i'.

module zad1(input [7:0] i, input [1:0] s, output [7:0] o);
  
  always_comb 
    begin
      case (s)
 		'b00 : o = i;
        'b01 : o = i+i;
        'b10 : o = i+i+i;
        'b11 : o = i+i+i+i;
        default o = i;
      endcase
    end
endmodule
          
/////////////////////////////

#Zadanie 2 
	Wartości wyjścia 'o' nie są ustawianie wewnątrz 'always_comb' na 0, przez co, gdy zaczniemy podawać kolejne liczby na wejściu, będziemy kumulować kolejne jedynki na wyjściu. Po pewnym czasie wyjście o będzie więc równe 1111, a powinno zapalać tylko jeden bit. Poniżej możliwe rozwiązanie problemu:
	
module dec2to4(input [1:0] i, input en, output [3:0] o);
  integer k;
  always_comb
    begin
      o = 0;
      for (k = 0; k <= 3; k = k + 1)
        if (i == k)
          o[k] = en;
    end
endmodule

/////////////////////////////

#Zadanie 3
	Kod implementuje dekoder 2 do 4, jednak nie robi w szczególnie optymalny sposób. Zamiast tworzyć cztery wyjścia 'y' można stworzyć jedno wyjście czterobitowe [3:0] y. Drugim problemem jest użycie zagnieżdżonych if-ów zamiast case. Użycie tej drugiej opcji wydatnie zwiększyło by czytelność kodu, a przy dobrej implementacji mogłoby skrocić ścieżkę krytyczną obwodu. Zatem implementacja układu w podanym w zadaniu stylu nie jest najbardziej optymalnym wyjściem.

/////////////////////////////

#Zadanie 4

Zauważyłem, że zadanie można rozwiązać stosując tylko pojedynczą instancję dekodera '2 do 4', ale żeby spełnić specyfikację zadania powieliłem tę instancję.

module decoder_2_to_4(input [1:0] i, output [3:0] o);
  always_comb
    case(i)
      2'd0: o = 4'b0001;
      2'd1: o = 4'b0010;
      2'd2: o = 4'b0100;
      2'd3: o = 4'b1000;
      endcase
endmodule
module circuit(input [2:0] i, output [7:0] o);
  logic [3:0] dec1;
  logic [3:0] dec2;
  logic [7:0] dec_3_to_8;
  logic [3:0] zero = 'b0000;
  
  decoder_2_to_4 dec_2_to_4_1(i[1:0], dec1);
  decoder_2_to_4 dec_2_to_4_2(i[1:0], dec2); //Powtórzenie pierwszego dekodera
  
  always_comb
    begin
      if (i[2] == 0) 
        begin
          dec_3_to_8 = {zero, dec1};
        end
      else if (i[2] == 1)
        begin
          dec_3_to_8 = {dec2, zero};
        end
    end
  
  assign o = dec_3_to_8;
         
endmodule



          
